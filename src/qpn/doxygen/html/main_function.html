<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>QP-nano: 3. The main() Function and the qpn_port.h Header File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.4 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="classes.html"><span>Data&nbsp;Structures</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul>
</div>
<div class="nav">
<a class="el" href="index.html">QP-nano Reference Manual</a>&nbsp;&raquo&nbsp;<a class="el" href="tutorial_page.html">QP-nano Tutorial</a></div>
<h1><a class="anchor" name="main_function">3. The main() Function and the <a class="el" href="qpn__port_8h.html" title="QP-nano port.">qpn_port.h</a> Header File </a></h1><em>This QP-nano Tutorial is adapted from Chapter 1 of <a class="el" href="index.html#PSiCC2">Practical UML Statecharts in C/C++, Second Edition</a><br>
 by Miro Samek, the founder and president of Quantum Leaps, LLC.</em><p>
<div align="center">
<img src="qp_tutorial.jpg" alt="qp_tutorial.jpg">
</div>
<p>
Prev: <a class="el" href="lets_play.html">2. Let's Play</a> <br>
 Next: <a class="el" href="design.html">4. Designing an Event-Driven Application</a><p>
Perhaps the best place to start the explanation of the "Fly 'n' Shoot" application code is the main() function, located in the file <code>main.c</code>. Unless indicated otherwise in this Tutorial, you can browse the code either in the DOS version, or the Cortex-M3 version, because the application source code is identical in both.<h2><a class="anchor" name="main_function">
3. The main() Function and the qpn_port.h Header File</a></h2>
<a class="el" href="main_function.html#L3s1">Listing 3-1</a> shows the <code>main.c</code> source file for the “Fly ‘n’ Shoot” application, which contains the <code>main()</code> function along with some important data structures required by QP-nano.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>To explain code listings, I place numbers in parentheses at the interesting lines in the left margin of the listing. I then use these labels in the left margin of the explanation section that immediately follows the listing. Occasionally, to unambiguously refer to a line of a particular listing from sections of text other than the explanation section, I use the full reference consisting of the listing number followed by the label. For example, <a class="el" href="main_function.html#L3s1">Listing 3-1</a>(21) refers to the label (21) in <a class="el" href="main_function.html#L3s1">Listing 3-1</a></dd></dl>
<a class="anchor" name="L3s1"></a> <b>Listing 3-1 The file main.c of the "Fly 'n' Shoot" game application. </b> <div class="fragment"><pre class="fragment"> (1) #include <span class="stringliteral">"qpn_port.h"</span>                                       <span class="comment">/* QP-nano port */</span>
 (2) #include <span class="stringliteral">"bsp.h"</span>                             <span class="comment">/* Board Support Package (BSP) */</span>
 (3) #include <span class="stringliteral">"game.h"</span>                                  <span class="comment">/* application interface */</span>

     <span class="comment">/*..........................................................................*/</span>
 (4) static <a class="code" href="struct_q_event.html" title="Event structure.">QEvent</a> l_tunnelQueue[GAME_MINES_MAX + 4];
 (5) static <a class="code" href="struct_q_event.html" title="Event structure.">QEvent</a> l_shipQueue[2];
 (6) static <a class="code" href="struct_q_event.html" title="Event structure.">QEvent</a> l_missileQueue[2];

     <span class="comment">/* QF_active[] array defines all active object control blocks --------------*/</span>
 (7) <a class="code" href="struct_q_active_c_b.html" title="QActive Control Block.">QActiveCB</a> const <a class="code" href="qpn__port_8h.html#4f4cc7253c4d809b326498b40efd66d3" title="Macro to specify compiler-specific directive for placing a constant object in ROM...">Q_ROM</a> <a class="code" href="qpn__port_8h.html#c4b8d7dd267fd787a004ad9b58ec2283" title="Macro to specify compiler-specific directive for accessing a constant object in ROM...">Q_ROM_VAR</a> QF_active[] = {
 (8)     { (<a class="code" href="struct_q_active.html" title="Active Object struct.">QActive</a> *)0,           (<a class="code" href="struct_q_event.html" title="Event structure.">QEvent</a> *)0,    0                     },
 (9)     { (<a class="code" href="struct_q_active.html" title="Active Object struct.">QActive</a> *)&amp;AO_tunnel,  l_tunnelQueue,  <a class="code" href="qepn_8h.html#d58d2c6dc25f8f0f764eb69faa79eee2" title="Macro to specify compiler-specific directive for placing a constant object in ROM...">Q_DIM</a>(l_tunnelQueue)  },
(10)     { (<a class="code" href="struct_q_active.html" title="Active Object struct.">QActive</a> *)&amp;AO_ship,    l_shipQueue,    <a class="code" href="qepn_8h.html#d58d2c6dc25f8f0f764eb69faa79eee2" title="Macro to specify compiler-specific directive for placing a constant object in ROM...">Q_DIM</a>(l_shipQueue)    },
(11)     { (<a class="code" href="struct_q_active.html" title="Active Object struct.">QActive</a> *)&amp;AO_missile, l_missileQueue, <a class="code" href="qepn_8h.html#d58d2c6dc25f8f0f764eb69faa79eee2" title="Macro to specify compiler-specific directive for placing a constant object in ROM...">Q_DIM</a>(l_missileQueue) }
     };

     <span class="comment">/* make sure that the QF_active[] array matches QF_MAX_ACTIVE in qpn_port.h */</span>
(12) <a class="code" href="qassert_8h.html#17f551ed8492f013d533f27353c091a3">Q_ASSERT_COMPILE</a>(<a class="code" href="qpn__port_8h.html#776d2a032974db4bf9bcfde01ace1389" title="The maximum number of active objects in the application.">QF_MAX_ACTIVE</a> == <a class="code" href="qepn_8h.html#d58d2c6dc25f8f0f764eb69faa79eee2" title="Macro to specify compiler-specific directive for placing a constant object in ROM...">Q_DIM</a>(QF_active) - 1);

     <span class="comment">/*..........................................................................*/</span>
     <span class="keywordtype">void</span> main (<span class="keywordtype">void</span>) {
(13)     Tunnel_ctor ();
(14)     Ship_ctor   ();
(15)     Missile_ctor(GAME_MISSILE_SPEED_X);

(16)     BSP_init();                                     <span class="comment">/* initialize the board */</span>

(17)     <a class="code" href="qfn_8h.html#7a41998117b4edb760b754f5ee3f61d5" title="Transfers control to QF to run the application.">QF_run</a>();                                <span class="comment">/* transfer control to QF-nano */</span>
     }
</pre></div><p>
<ul>
<li>(1) Every application C-file that uses QP-nano must include the <code><a class="el" href="qpn__port_8h.html" title="QP-nano port.">qpn_port.h</a></code> header file. This header file contains the specific adaptation of QP-nano to the given processor and compiler, which is called a port. The QP port is typically located in the application directory.</li>
</ul>
<ul>
<li>(2) The <code>bsp.h</code> header file contains the interface to the Board Support Package and is located in the application directory.</li>
</ul>
<ul>
<li>(3) The <code>game.h</code> header file contains the declarations of events and other facilities shared among the components of the "Fly 'n' Shoot" game. This header file is located in the application directory.</li>
</ul>
<ul>
<li>(4-6) The application must provide storage for the event queues of all active objects used in the application. In QP-nano the storage is provided at compile time through the statically allocated arrays of events. Events are represented as instances of the <a class="el" href="struct_q_event.html" title="Event structure.">QEvent</a> structure declared in the <code>&lt;qpn&gt;\include\<a class="el" href="qepn_8h.html" title="Public QEP-nano interface.">qepn.h</a></code> header file, included from <code><a class="el" href="qpn__port_8h.html" title="QP-nano port.">qpn_port.h</a></code>. Each event queue of an active object can have a different length and you need to decide this length based on your knowledge of the application. Please refer to Chapters 6 and 7 in <a class="el" href="index.html#PSiCC2">Practical UML Statecharts in C/C++, Second Edition</a> for the discussion of sizing event queues.</li>
</ul>
<ul>
<li>(7) Every QP-nano application must provide the constant array <code>QF_active</code>[], which defines all active object control blocks in the application. The control block <code><a class="el" href="struct_q_active_c_b.html" title="QActive Control Block.">QActiveCB</a></code> structure groups together: (1) the pointer to the corresponding active object instance, (2) the pointer to the event queue buffer of the active object, and (3) the length of the queue buffer.</li>
</ul>
In QP-nano, I use every opportunity to place data in ROM rather than in the precious RAM. The <a class="el" href="struct_q_active_c_b.html" title="QActive Control Block.">QActiveCB</a> structure contains data elements known at compile time, so that these elements can be placed in ROMas opposed to placing them in the active object structure (RAM). That way, I save anywhere from 10 to 80 bytes of RAM, depending on the number of active objects and the pointer size of the target CPU. The Q_ROM macro is necessary on some CPU architecture to enforce placement of constant objects, such as the QF_active[] array, in ROM. On Harvard architecture CPUs (such as 8051 or AVR), the code and data spaces are separate and are accessed through different CPU instructions. The const keyword is not sufficient to place data in ROM, and various compilers often provide specific extended keywords to designate the code space for placing constant data, such as the "__code" extended keyword in the IAR 8051 compiler. The macro Q_ROM hides such non-standard extensions. If you don't define Q_ROM in qepn_port.h, it will be defined to nothing in the <a class="el" href="qepn_8h.html" title="Public QEP-nano interface.">qepn.h</a> platform-independent header file. The Q_ROM_VAR macro defines the compiler-specific directive for accessing a constant object in ROM. Many compilers for 8-bit MCUs provide different size pointers for accessing objects in various memories. Constant objects allocated in ROM often mandate the use of specific-size pointers (e.g., far pointers) to get access to ROM objects. The macro Q_ROM_VAR specifies the kind of the pointer to be used to access the ROM objects. An example of valid Q_ROM_VAR macro definition is: __far (Freescale HC(S)08 compiler).<p>
<ul>
<li>(8) The first entry (<code>QF_active</code>[0]) corresponds to active object priority of zero, which is reserved for the idle task and cannot be used for any active object.</li>
</ul>
<ul>
<li>(9-11) The <code>QF_active</code>[] entries starting from one define the active object control blocks in the order of their relative priorities. The maximum number of active objects in QP-nano cannot exceed 8.</li>
</ul>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The order or the active object control blocks in the <code>QF_active</code>[] array defines the priorities of active objects. This is the only place in the code where you assign active object priorities.</dd></dl>
<ul>
<li>(12) This compile-time assertion (see Chapter 6 in <a class="el" href="index.html#PSiCC2">Practical UML Statecharts in C/C++, Second Edition</a>) ensures that the dimension of the QF_active[] array matches the number of active objects <a class="el" href="qpn__port_8h.html#776d2a032974db4bf9bcfde01ace1389" title="The maximum number of active objects in the application.">QF_MAX_ACTIVE</a> defined in the <code><a class="el" href="qpn__port_8h.html" title="QP-nano port.">qpn_port.h</a></code> header file.</li>
</ul>
In QP-nano, <a class="el" href="qpn__port_8h.html#776d2a032974db4bf9bcfde01ace1389" title="The maximum number of active objects in the application.">QF_MAX_ACTIVE</a> denotes the exact number of active objects used in the application, as opposed to the full-version QP, where <a class="el" href="qpn__port_8h.html#776d2a032974db4bf9bcfde01ace1389" title="The maximum number of active objects in the application.">QF_MAX_ACTIVE</a> denotes just the configurable maximum number of active objects.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>All active objects in QP-nano must be defined at compile time. This means that all active objects exist from the beginning and cannot be started (or stopped) later, as it is possible in the full-version QP.</dd></dl>
The macro <a class="el" href="qpn__port_8h.html#776d2a032974db4bf9bcfde01ace1389" title="The maximum number of active objects in the application.">QF_MAX_ACTIVE</a> must be defined in <a class="el" href="qpn__port_8h.html" title="QP-nano port.">qpn_port.h</a> header file, because QP-nano uses the macro to optimize the internal algorithms based on the number of active objects. The compile-time assertion in line (12) makes sure that the configured number of active objects indeed matches exactly the number of active object control blocks defined in the <code>QF_active</code>[] array.<p>
<ul>
<li>(13-15) The <code>main()</code> function must first explicitly calls all active object constructors.</li>
</ul>
<ul>
<li>(16) The board support package (BSP) is initialized.</li>
</ul>
<ul>
<li>(17) At this point, you have initialized all components and have provided to the QF-nano framework all the information it needs to manage your application. The last thing you must do is to call the function <code><a class="el" href="qfn_8h.html#7a41998117b4edb760b754f5ee3f61d5" title="Transfers control to QF to run the application.">QF_run()</a></code> to pass the control to the QF-nano framework.</li>
</ul>
Overall, the application startup is much simpler in QP-nano than in full-version QP. Neither event pools, nor publish-subscribe lists are supported, so you don't need to initialize them. You also don't start active objects explicitly. The QF-nano framework starts all active objects defined in the <code>QF_active</code>[] array automatically just after it gets control in <code><a class="el" href="qfn_8h.html#7a41998117b4edb760b754f5ee3f61d5" title="Transfers control to QF to run the application.">QF_run()</a></code>.<h2><a class="anchor" name="qpn_porth_h">
The qpn_port.h header file</a></h2>
The <code><a class="el" href="qpn__port_8h.html" title="QP-nano port.">qpn_port.h</a></code> header file defines the QP-nano port and all configuration parameters for the particular application. Unlike in the full-version QP, QP-nano ports are typically defined at the application level. Typically also, the whole QP-nano port consists of just the <a class="el" href="qpn__port_8h.html" title="QP-nano port.">qpn_port.h</a> header file. <a class="el" href="main_function.html#L3s2">Listing 3-2</a> shows the complete <code><a class="el" href="qpn__port_8h.html" title="QP-nano port.">qpn_port.h</a></code> file for the DOS version of the “Fly ‘n’ Shoot” game.<p>
<a class="anchor" name="L3s2"></a> <b>Listing 3-2 The <a class="el" href="qpn__port_8h.html" title="QP-nano port.">qpn_port.h</a> header file for the “Fly ‘n’ Shoot” game. </b> <div class="fragment"><pre class="fragment"><span class="preprocessor">     #ifndef qpn_port_h</span>
<span class="preprocessor"></span><span class="preprocessor">     #define qpn_port_h</span>
<span class="preprocessor"></span>
 (1) #define <a class="code" href="qpn__port_8h.html#44b94e1d4ae451b6c67d6503999714a8" title="The size (in bytes) of the single scalar parameter representation in the QEvent struct...">Q_PARAM_SIZE</a>            4
 (2) #define <a class="code" href="qpn__port_8h.html#80d059a0d02a2573c76f4eb5df0228ae" title="The size (in bytes) of the time event-counter representation in the QActive struct...">QF_TIMEEVT_CTR_SIZE</a>     2
 (3) #define Q_NFSM

     <span class="comment">/* maximum # active objects--must match EXACTLY the QF_active[] definition  */</span>
 (4) <span class="preprocessor">#define QF_MAX_ACTIVE           3</span>
<span class="preprocessor"></span>
                                      <span class="comment">/* interrupt locking policy for task level */</span>
 (5) #define <a class="code" href="qpn__port_8h.html#7b1b0af0b1806fc6a017f30914318a61" title="The macro defines the mechanism of locking the interrupts.">QF_INT_LOCK</a>()           disable()
 (6) <span class="preprocessor">#define QF_INT_UNLOCK()         enable()</span>
<span class="preprocessor"></span>
     <span class="comment">/* Exact-width types (WG14/N843 C99 Standard) for Turbo C++/large model     */</span>
 (7) <span class="keyword">typedef</span> <span class="keywordtype">signed</span>   <span class="keywordtype">char</span>  int8_t;
     <span class="keyword">typedef</span> <span class="keywordtype">signed</span>   <span class="keywordtype">int</span>   int16_t;
     <span class="keyword">typedef</span> <span class="keywordtype">signed</span>   <span class="keywordtype">long</span>  int32_t;
     <span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>  uint8_t;
     <span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>   uint16_t;
     <span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>  uint32_t;

<span class="preprocessor">     #include &lt;dos.h&gt;</span>                                                 <span class="comment">/* DOS API */</span>
<span class="preprocessor">     #undef outportb </span><span class="comment">/*don't use the macro because it has a bug in Turbo C++ 1.01*/</span>

 (8) #include <span class="stringliteral">"qepn.h"</span>              <span class="comment">/* QEP-nano platform-independent header file */</span>
 (9) #include <span class="stringliteral">"qfn.h"</span>                <span class="comment">/* QF-nano platform-independent header file */</span>

<span class="preprocessor">     #endif                                                        </span><span class="comment">/* qpn_port_h */</span>
</pre></div><p>
<ul>
<li>(1) The macro <a class="el" href="qpn__port_8h.html#44b94e1d4ae451b6c67d6503999714a8" title="The size (in bytes) of the single scalar parameter representation in the QEvent struct...">Q_PARAM_SIZE</a> defines the size (in bytes) of the scalar event parameter. The allowed values are 0 (no parameter), 1, 2, or 4 bytes. If you don't define this macro in <a class="el" href="qpn__port_8h.html" title="QP-nano port.">qpn_port.h</a>, the default of 0 (no parameter) will be assumed.</li>
</ul>
<ul>
<li>(2) The macro <a class="el" href="qpn__port_8h.html#80d059a0d02a2573c76f4eb5df0228ae" title="The size (in bytes) of the time event-counter representation in the QActive struct...">QF_TIMEEVT_CTR_SIZE</a> defines the size (in bytes) of the time event down-counter. The allowed values are 0 (no time events), 1, 2, or 4 bytes. If you don't define this macro in <a class="el" href="qpn__port_8h.html" title="QP-nano port.">qpn_port.h</a>, the default of 0 (no time events) will be assumed.</li>
</ul>
<ul>
<li>(3) Defining the macro Q_NFSM eliminates the code for the simple non-hierarchical FSMs.</li>
</ul>
<ul>
<li>(4) You must define the QF_MAX_ACTIVE macro as the exact number of active objects used in the application. The provided value must be between 1 and 8 and must be consistent with the definition of the <code>QF_active</code>[] array (see <a class="el" href="main_function.html#L3s1">Listing 3-1</a>(12)).</li>
</ul>
<ul>
<li>(5-6) The macros <a class="el" href="qpn__port_8h.html#7b1b0af0b1806fc6a017f30914318a61" title="The macro defines the mechanism of locking the interrupts.">QF_INT_LOCK()</a>/<a class="el" href="qpn__port_8h.html#adf9dd2f2988e2f2f9127374629316c9" title="The macro defines the mechanism of unlocking the interrupts.">QF_INT_UNLOCK()</a> define the task-level interrupt locking policy for QP-nano. I discuss QP-nano critical section in Chapter 12 of <a class="el" href="index.html#PSiCC2">Practical UML Statecharts in C/C++, Second Edition</a>.</li>
</ul>
<ul>
<li>(7) Just like the full-version QP, QP-nano uses a subset of the C99-standard exact-with integer types. The legacy Turbo C++ 1.01 compiler, which I'm using here, is a pre-standard compiler and does not provide the <code>&lt;stdint.h&gt;</code> header file. In this case I just typedef the six exact-width integer types used in QP-nano.</li>
</ul>
<ul>
<li>(8) The <code><a class="el" href="qpn__port_8h.html" title="QP-nano port.">qpn_port.h</a></code> must include the QEP-nano event processor interface <code><a class="el" href="qepn_8h.html" title="Public QEP-nano interface.">qepn.h</a></code>.</li>
</ul>
<ul>
<li>(9) <code>The</code> <a class="el" href="qpn__port_8h.html" title="QP-nano port.">qpn_port.h</a> must include the QF-nano real-time framework interface <code><a class="el" href="qfn_8h.html" title="Public QF-nano interface.">qfn.h</a></code>.</li>
</ul>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The <code><a class="el" href="qpn__port_8h.html" title="QP-nano port.">qpn_port.h</a></code> header file in <a class="el" href="main_function.html#L3s2">Listing 3-2</a> implicitly configures QP-nano to use the built-in cooperative "vanilla" kernel. The other alternative, which is the preemptive QK-nano kernel, is configured automatically when you include the <code><a class="el" href="qkn_8h.html" title="Public QP-nano interface.">qkn.h</a></code> QK-nano interface in the <code><a class="el" href="qpn__port_8h.html" title="QP-nano port.">qpn_port.h</a></code> header file.</dd></dl>
Prev: <a class="el" href="lets_play.html">2. Let's Play</a> <br>
 Next: <a class="el" href="design.html">4. Designing an Event-Driven Application</a><p>
<div align="center">
<img src="logo_ql_TM.jpg" alt="logo_ql_TM.jpg">
</div>
 Copyright &copy; 2002-2008 Quantum Leaps, LLC. All Rights Reserved.<br>
 <a href="http://www.quantum-leaps.com">http://www.quantum-leaps.com</a> <hr size="1"><address style="text-align: right;"><small>Generated on Thu Apr 9 13:26:45 2009 for QP-nano by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.4 </small></address>
</body>
</html>
