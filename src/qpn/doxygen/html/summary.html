<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>QP-nano: 11. Summary</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.4 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="classes.html"><span>Data&nbsp;Structures</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul>
</div>
<div class="nav">
<a class="el" href="index.html">QP-nano Reference Manual</a>&nbsp;&raquo&nbsp;<a class="el" href="tutorial_page.html">QP-nano Tutorial</a></div>
<h1><a class="anchor" name="summary">11. Summary </a></h1><em>This QP-nano Tutorial is adapted from Chapter 1 of <a class="el" href="index.html#PSiCC2">Practical UML Statecharts in C/C++, Second Edition</a><br>
 by Miro Samek, the founder and president of Quantum Leaps, LLC.</em><p>
<div align="center">
<img src="qp_tutorial.jpg" alt="qp_tutorial.jpg">
</div>
<p>
Prev: <a class="el" href="comparison.html">10. Comparison to the Traditional Approach</a><p>
If you've never done event-driven programming before, the internal structure of the "Fly 'n' Shoot" game must certainly represent a big paradigm shift for you. In fact, I hope that it actually blows your mind, because otherwise I'm not sure that you really appreciate the complete reversal of control of an event-driven program compared to the traditional sequential code. This reversal of control, known as the "Hollywood Principle" (don't call us, we'll call you), baffles many newcomers, who often find it "mind-boggling", "backwards", or "weird".<p>
My main goal in this Tutorial was just to introduce you to the event-driven paradigm and the modern state machines to convince you that these powerful concepts aren't particularly hard to implement directly in C or C++. Indeed, I hope you noticed that the actual coding of the nontrivial "Fly 'n' Shoot" game wasn't a big deal at all. All you needed to know was just a few cookie-cutter rules for coding state machines and familiarity with a few framework services for implementing the actions.<p>
Wile the coding turned out to be essentially a non-issue; the bulk of the programming effort was spent on the design of the application. At this point, I hope that the "Fly 'n' Shoot" example helps you to get the big picture of how the method works. Under the event driven model, the program structure is divided into two rough groups: events and state machine components (active objects). An event represents the occurrence of something interesting. A state machine codifies the reactions to the events, which generally depend both on the nature of the event and on the state of the component. While events often originate from the outside of your program, such as time ticks or button presses in the "Fly 'n' Shoot" game, events can also be generated internally by the program itself. For example the Mine components generate notification events when they detect a collision with the Missile or the Ship.<p>
An event-driven program executes by constantly checking for possible events and, when an event is detected, dispatching the event to the appropriate state machine component (see <a class="el" href="comparison.html#F10s1">Figure 10-1</a>(b)). In order for this approach to work, the events must be checked continuously and frequently. This implies that the state machines must execute quickly, so that the program can get back to checking for events. In order to meet this requirement, a state machine cannot go into a condition where it is busy-waiting for some long or indeterminate time. The most common example of this would be a while loop inside a state-handler function, where the condition for termination was not under program control, for instance the button press. This kind of program structure, an indefinite loop, is referred to as "blocking" code6, and you saw examples of it in the "Quickstart" application (see <a class="el" href="comparison.html#F10s1">Figure 10-1</a>(a)). In order for the event driven programming model to work, you must only write "non-blocking" code.<p>
Finally, the "Fly 'n' Shoot" example demonstrates the use of the event-driven platform called QP-nano, which is a collection of components for building event-driven application. The QF-nano real-time framework component framework embodies the "Hollywood principle", by calling the application code, not the other way around. Such arrangement is very typical for event-driven systems and application frameworks similar to QF-nano are at the heart of virtually every design automation tool on the market today.<p>
The QP-nano event-driven platform scales down better and than any traditional RTOS or real-time kernel. In fact, you can view QP-nano as a high-level, event-driven, real-time operating system for tiny, low-end embedded systems.<p>
Prev: <a class="el" href="comparison.html">10. Comparison to the Traditional Approach</a><p>
<div align="center">
<img src="logo_ql_TM.jpg" alt="logo_ql_TM.jpg">
</div>
 Copyright &copy; 2002-2008 Quantum Leaps, LLC. All Rights Reserved.<br>
 <a href="http://www.quantum-leaps.com">http://www.quantum-leaps.com</a> <hr size="1"><address style="text-align: right;"><small>Generated on Thu Apr 9 13:26:46 2009 for QP-nano by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.4 </small></address>
</body>
</html>
