<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>QP-nano: 8. Using the Built-in Real-Time Kernels</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.4 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="classes.html"><span>Data&nbsp;Structures</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul>
</div>
<div class="nav">
<a class="el" href="index.html">QP-nano Reference Manual</a>&nbsp;&raquo&nbsp;<a class="el" href="tutorial_page.html">QP-nano Tutorial</a></div>
<h1><a class="anchor" name="execution">8. Using the Built-in Real-Time Kernels </a></h1><em>This QP-nano Tutorial is adapted from Chapter 1 of <a class="el" href="index.html#PSiCC2">Practical UML Statecharts in C/C++, Second Edition</a><br>
 by Miro Samek, the founder and president of Quantum Leaps, LLC.</em><p>
<div align="center">
<img src="qp_tutorial.jpg" alt="qp_tutorial.jpg">
</div>
<p>
Prev: <a class="el" href="coding_hsm.html">7. Coding Hierarchical State Machines</a> <br>
 Next: <a class="el" href="code_size.html">9. QP-nano Memory Usage</a><p>
As you saw in <a class="el" href="main_function.html#L3s1">Listing 3-1</a>(17), the <code>main()</code> function eventually gives control to the QF-nano framework by calling <a class="el" href="qfn_8h.html#7a41998117b4edb760b754f5ee3f61d5" title="Transfers control to QF to run the application.">QF_run()</a> to execute the application. In this section, I briefly explain how QF-nano allocates the CPU cycles to various tasks within the system and what options you have in choosing the execution model.<h2><a class="anchor" name="using_vanilla">
8.1 Simple Non-Preemptive "Vanilla" Kernel</a></h2>
In the simplest configuration, the "Fly 'n' Shoot" game executes under the simple cooperative "vanilla" kernel, which is provided in the QP-nano. The "vanilla" kernel operates by constantly polling all event queues of active objects in an endless loop. The kernel always selects the highest-priority active object ready to run, which is the highest-priority active object with a non-empty event queue.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The "vanilla" kernel is so simple that many commercial real-time frameworks don't even call it a kernel . Instead, this configuration is simply referred to as "without an RTOS". However, if you want to understand what it means to execute active objects "without an RTOS" and what execution profile you can expect in this case, you need to realize that a simple cooperative vanilla kernel is indeed involved.</dd></dl>
The interrupt service routines (ISRs) can preempt the execution of active objects at any time, but due to the simplistic nature of the "vanilla" kernel, every ISR returns to exactly the preemption point. If the ISR posts or publishes an event to any active object, the processing of this event won't start until the current RTC step completes. The maximum time an event for the highest-priority active object can be delayed this way is called the task-level response. With the non-preemptive "vanilla" kernel, the task-level response is equal to the longest RTC step of all active objects in the system. Please note that the task-level response of the "vanilla" kernel is still a lot better than the traditional "superloop" (a.k.a., main+ISRs) architecture. I'll have more to say about this in the upcoming Section <a class="el" href="comparison.html">10. Comparison to the Traditional Approach</a>, where I compare the event-driven "Fly 'n' Shoot" example to the traditionally structured "Quickstart" application.<p>
The task-level response of the simple "vanilla" kernel turns out to be adequate for surprisingly many applications, because state machines by nature handle events quickly without a need to busy-wait for events. (A state machine simply runs-to-completion and becomes dormant until another event arrives). Please also note that often you can make the task-level response as fast as you need by breaking up longer RTC steps into shorter ones (e.g., by using the "Reminder" state pattern described in Chapter 5 of <a class="el" href="index.html#PSiCC2">Practical UML Statecharts in C/C++, Second Edition</a>.<h2><a class="anchor" name="using_QK">
8.2 The QK-nano Preemptive Kernel</a></h2>
In some cases, breaking up long RTC steps into short enough pieces might be very difficult, and consequently the task-level response of the non-preemptive "vanilla" kernel might be too long. An example system could be a GPS receiver. Such a receiver performs a lot of floating point number crunching on a fixed-point CPU to calculate the GPS position. At the same time, the GPS receiver must track the GPS satellite signals, which involves closing control loops in sub-millisecond intervals. It turns out that it's not easy to break up the position-fix computation into short enough RTC steps to allow reliable signal tracking. But the RTC semantics of state machine execution does not mean that a state machine has to monopolize the CPU for the duration of the RTC step. A preemptive kernel can perform a context switch in the middle of the long RTC step to allow a higher-priority active object to run. As long as the active objects don't share resources they can run concurrently and complete their RTC steps independently.<p>
The QP-nano event-driven platform includes a tiny, fully preemptive, priority-based real-time kernel component called QK-nano, which is specifically designed for processing events in the RTC fashion. Configuring QP-nano to use the preemptive QK-nano kernel is very easy, but as with any fully preemptive kernel you must be very careful with any resources shared among active objects5. The "Fly 'n' Shoot" example has been purposely designed to avoid any resource sharing among active objects, so the application code does not need to change at all to run on top of the QK-nano preemptive kerel, or any other preemptive kernel or RTOS for that matter. The accompanying code contains the "Fly 'n' Shoot" example with QK in the following directory: &lt;qpn&gt;\examples\80x86\tcpp101\game-qk\. You can execute this example in a DOS-console on any standard Windows-based PC.<p>
Prev: <a class="el" href="coding_hsm.html">7. Coding Hierarchical State Machines</a> <br>
 Next: <a class="el" href="code_size.html">9. QP-nano Memory Usage</a><p>
<div align="center">
<img src="logo_ql_TM.jpg" alt="logo_ql_TM.jpg">
</div>
 Copyright &copy; 2002-2008 Quantum Leaps, LLC. All Rights Reserved.<br>
 <a href="http://www.quantum-leaps.com">http://www.quantum-leaps.com</a> <hr size="1"><address style="text-align: right;"><small>Generated on Thu Apr 9 13:26:46 2009 for QP-nano by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.4 </small></address>
</body>
</html>
