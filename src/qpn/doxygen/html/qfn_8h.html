<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>QP-nano: qfn.h File Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.4 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="classes.html"><span>Data&nbsp;Structures</span></a></li>
    <li class="current"><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul>
</div>
<h1>qfn.h File Reference</h1>Public QF-nano interface. <a href="#_details">More...</a>
<p>

<p>
<a href="qfn_8h-source.html">Go to the source code of this file.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_q_active.html">QActive</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Active Object struct.  <a href="struct_q_active.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_q_active_c_b.html">QActiveCB</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="struct_q_active.html" title="Active Object struct.">QActive</a> Control Block.  <a href="struct_q_active_c_b.html#_details">More...</a><br></td></tr>
<tr><td colspan="2"><br><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="qfn_8h.html#abc3bb6d854fe3a71937f0a09764f8f7">Q_ROM_BYTE</a>(rom_var_)&nbsp;&nbsp;&nbsp;(rom_var_)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Macro to access a byte allocated in ROM.  <a href="#abc3bb6d854fe3a71937f0a09764f8f7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="qfn_8h.html#4fa2969ab20fd9510637d9ac4e662698">Q_ROM_PTR</a>(rom_var_)&nbsp;&nbsp;&nbsp;(rom_var_)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Macro to access a pointer allocated in ROM.  <a href="#4fa2969ab20fd9510637d9ac4e662698"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="qfn_8h.html#7ddf2dd243b2bc13589a9c7d22f0e253">QActive_ctor</a>(me_, initial_)&nbsp;&nbsp;&nbsp;QHsm_ctor(&amp;(me_)-&gt;super, initial_)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Active object constructor.  <a href="#7ddf2dd243b2bc13589a9c7d22f0e253"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef uint16_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="qfn_8h.html#4c9ee418dab7af7004cfd9ebbb5bc8f5">QTimeEvtCtr</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">type of the Time Event counter, which determines the dynamic range of the time delays measured in clock ticks.  <a href="#4c9ee418dab7af7004cfd9ebbb5bc8f5"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="qfn_8h.html#079baf20c44aae3d8b6bc1200c0b07a1">QActive_post</a> (<a class="el" href="struct_q_active.html">QActive</a> *me, <a class="el" href="qepn_8h.html#5dae830cf35fbe668a3fa2b47452a36b">QSignal</a> sig, <a class="el" href="qepn_8h.html#691c7fae67ced229a9dd9fa1ef048379">QParam</a> par)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Posts an event <em>e</em> directly to the event queue of the acitve object <em>prio</em> using the First-In-First-Out (FIFO) policy. This function briefly locks and unlocks interrupts to protect the queue integrity.  <a href="#079baf20c44aae3d8b6bc1200c0b07a1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="qfn_8h.html#d0a147ddbdfc4d9450f64515ae75f7a6">QActive_postISR</a> (<a class="el" href="struct_q_active.html">QActive</a> *me, <a class="el" href="qepn_8h.html#5dae830cf35fbe668a3fa2b47452a36b">QSignal</a> sig, <a class="el" href="qepn_8h.html#691c7fae67ced229a9dd9fa1ef048379">QParam</a> par)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Posts an event <em>e</em> directly to the event queue of the acitve object <em>prio</em> using the First-In-First-Out (FIFO) policy. This function does NOT lock/unlock interrupts when nesting of interrupts is not allowed. Also, this function never calls the QK-nano scheduler, because synchronous task preemptions are never necessary inside ISRs.  <a href="#d0a147ddbdfc4d9450f64515ae75f7a6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="qfn_8h.html#fd1f18b068ca10c17eaa3431e77dd290">QF_tick</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Processes all armed time events at every clock tick.  <a href="#fd1f18b068ca10c17eaa3431e77dd290"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="qfn_8h.html#0acd0429fdee5beb25d06607ca190846">QActive_arm</a> (<a class="el" href="struct_q_active.html">QActive</a> *me, <a class="el" href="qfn_8h.html#4c9ee418dab7af7004cfd9ebbb5bc8f5">QTimeEvtCtr</a> tout)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Arm the QP-nano one-shot time event. Since the tick counter is a multi-byte variable in this case, the operation must be performed inside a critical section.  <a href="#0acd0429fdee5beb25d06607ca190846"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="qfn_8h.html#27256e6403711f1f55e2b6a586b00bab">QActive_disarm</a> (<a class="el" href="struct_q_active.html">QActive</a> *me)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Disarm a time event. Since the tick counter is a multi-byte variable in this case, the operation must be performed inside a critical section.  <a href="#27256e6403711f1f55e2b6a586b00bab"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="qfn_8h.html#df9cb86740bf55c5ad55c1d44fd35921">QF_stop</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">QF-nano termination.  <a href="#df9cb86740bf55c5ad55c1d44fd35921"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="qfn_8h.html#189a6d2ece787717c81fbf51fd180732">QF_onStartup</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Startup QF-nano callback.  <a href="#189a6d2ece787717c81fbf51fd180732"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="qfn_8h.html#7a41998117b4edb760b754f5ee3f61d5">QF_run</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Transfers control to QF to run the application.  <a href="#7a41998117b4edb760b754f5ee3f61d5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="qfn_8h.html#fcac91c9d71d70255fdd88db3fb16e24">QF_onIdle</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">QF idle callback (customized in BSPs for QF).  <a href="#fcac91c9d71d70255fdd88db3fb16e24"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Variables</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="struct_q_active_c_b.html">QActiveCB</a> const Q_ROM Q_ROM_VAR&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="qfn_8h.html#d7859aaf627fc134851ae64c9ff9ed6f">QF_active</a> []</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">uint8_t volatile&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="qfn_8h.html#2be032c7d9fdaa52f5e89d0f8856b768">QF_readySet_</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Ready set of QF-nano.  <a href="#2be032c7d9fdaa52f5e89d0f8856b768"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Public QF-nano interface. 
<p>
This header file must be included in all modules that use QP-nano. Typically, this header file is included indirectly through the header file <a class="el" href="qpn__port_8h.html" title="QP-nano port.">qpn_port.h</a>. 
<p>Definition in file <a class="el" href="qfn_8h-source.html">qfn.h</a>.</p>
<hr><h2>Define Documentation</h2>
<a class="anchor" name="abc3bb6d854fe3a71937f0a09764f8f7"></a><!-- doxytag: member="qfn.h::Q_ROM_BYTE" ref="abc3bb6d854fe3a71937f0a09764f8f7" args="(rom_var_)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Q_ROM_BYTE          </td>
          <td>(</td>
          <td class="paramtype">rom_var_&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">&nbsp;&nbsp;&nbsp;(rom_var_)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Macro to access a byte allocated in ROM. 
<p>
Some compilers for Harvard-architecture MCUs, such as gcc for AVR, do not generate correct code for accessing data allocated in the program space (ROM). The workaround for such compilers is to explictly add assembly code to access each data element allocated in the program space. The macro <a class="el" href="qpn__port_8h.html#abc3bb6d854fe3a71937f0a09764f8f7" title="Macro to access a byte allocated in ROM.">Q_ROM_BYTE()</a> retrieves a byte from the given ROM address.<p>
The <a class="el" href="qpn__port_8h.html#abc3bb6d854fe3a71937f0a09764f8f7" title="Macro to access a byte allocated in ROM.">Q_ROM_BYTE()</a> macro should be defined in the <a class="el" href="qpn__port_8h.html" title="QP-nano port.">qpn_port.h</a> header file for each compiler that cannot handle correctly data allocated in ROM (such as the gcc). If the macro is left undefined, the default definition simply returns the argument and lets the compiler synthesize the correct code. 
<p>Definition at line <a class="el" href="qfn_8h-source.html#l00071">71</a> of file <a class="el" href="qfn_8h-source.html">qfn.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="4fa2969ab20fd9510637d9ac4e662698"></a><!-- doxytag: member="qfn.h::Q_ROM_PTR" ref="4fa2969ab20fd9510637d9ac4e662698" args="(rom_var_)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Q_ROM_PTR          </td>
          <td>(</td>
          <td class="paramtype">rom_var_&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">&nbsp;&nbsp;&nbsp;(rom_var_)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Macro to access a pointer allocated in ROM. 
<p>
Some compilers for Harvard-architecture MCUs, such as gcc for AVR, do not generate correct code for accessing data allocated in the program space (ROM). The workaround for such compilers is to explictly add assembly code to access each data element allocated in the program space. The macro <a class="el" href="qpn__port_8h.html#4fa2969ab20fd9510637d9ac4e662698" title="Macro to access a pointer allocated in ROM.">Q_ROM_PTR()</a> retrieves an object-pointer from the given ROM address. Please note that the pointer can be pointing to the object in RAM or ROM.<p>
The <a class="el" href="qpn__port_8h.html#4fa2969ab20fd9510637d9ac4e662698" title="Macro to access a pointer allocated in ROM.">Q_ROM_PTR()</a> macro should be defined in the <a class="el" href="qpn__port_8h.html" title="QP-nano port.">qpn_port.h</a> header file for each compiler that cannot handle correctly data allocated in ROM (such as the gcc). If the macro is left undefined, the default definition simply returns the argument and lets the compiler synthesize the correct code. 
<p>Definition at line <a class="el" href="qfn_8h-source.html#l00090">90</a> of file <a class="el" href="qfn_8h-source.html">qfn.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="7ddf2dd243b2bc13589a9c7d22f0e253"></a><!-- doxytag: member="qfn.h::QActive_ctor" ref="7ddf2dd243b2bc13589a9c7d22f0e253" args="(me_, initial_)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define QActive_ctor          </td>
          <td>(</td>
          <td class="paramtype">me_,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">initial_&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">&nbsp;&nbsp;&nbsp;QHsm_ctor(&amp;(me_)-&gt;super, initial_)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Active object constructor. 
<p>
<em>me</em> pointer the active object structure derived from <a class="el" href="struct_q_active.html" title="Active Object struct.">QActive</a>. <em>initial</em> is the pointer to the initial state of the active object.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Must be called exactly ONCE for each active object in the application before calling <a class="el" href="qfn_8h.html#7a41998117b4edb760b754f5ee3f61d5" title="Transfers control to QF to run the application.">QF_run()</a>. </dd></dl>

<p>Definition at line <a class="el" href="qfn_8h-source.html#l00182">182</a> of file <a class="el" href="qfn_8h-source.html">qfn.h</a>.</p>

</div>
</div><p>
<hr><h2>Typedef Documentation</h2>
<a class="anchor" name="4c9ee418dab7af7004cfd9ebbb5bc8f5"></a><!-- doxytag: member="qfn.h::QTimeEvtCtr" ref="4c9ee418dab7af7004cfd9ebbb5bc8f5" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef uint16_t <a class="el" href="qfn_8h.html#4c9ee418dab7af7004cfd9ebbb5bc8f5">QTimeEvtCtr</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
type of the Time Event counter, which determines the dynamic range of the time delays measured in clock ticks. 
<p>
This typedef is configurable via the preprocessor switch <a class="el" href="qpn__port_8h.html#80d059a0d02a2573c76f4eb5df0228ae" title="The size (in bytes) of the time event-counter representation in the QActive struct...">QF_TIMEEVT_CTR_SIZE</a>. The other possible values of this type are as follows: <br>
 none when (QF_TIMEEVT_CTR_SIZE not defined or == 0), <br>
 uint8_t when (QF_TIMEEVT_CTR_SIZE == 1); <br>
 uint16_t when (QF_TIMEEVT_CTR_SIZE == 2); and <br>
 uint32_t when (QF_TIMEEVT_CTR_SIZE == 4). 
<p>Definition at line <a class="el" href="qfn_8h-source.html#l00114">114</a> of file <a class="el" href="qfn_8h-source.html">qfn.h</a>.</p>

</div>
</div><p>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="0acd0429fdee5beb25d06607ca190846"></a><!-- doxytag: member="qfn.h::QActive_arm" ref="0acd0429fdee5beb25d06607ca190846" args="(QActive *me, QTimeEvtCtr tout)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QActive_arm           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_q_active.html">QActive</a> *&nbsp;</td>
          <td class="paramname"> <em>me</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="qfn_8h.html#4c9ee418dab7af7004cfd9ebbb5bc8f5">QTimeEvtCtr</a>&nbsp;</td>
          <td class="paramname"> <em>tout</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Arm the QP-nano one-shot time event. Since the tick counter is a multi-byte variable in this case, the operation must be performed inside a critical section. 
<p>
Arms the time event of the active object <em>me</em> to expire in <em>tout</em> clock ticks (one-shot time event). Upon the expiration, the time event posts the reserved signal Q_TIMEOUT_SIG directly into the event queue of the active object <em>me</em>.<p>
After posting, the time event gets automatically disarmed.<p>
The time event can be disarmed (stoped) at any time by calling the <a class="el" href="qfn_8h.html#27256e6403711f1f55e2b6a586b00bab" title="Disarm a time event. Since the tick counter is a multi-byte variable in this case...">QActive_disarm()</a> function. Also, a one-shot time event can be re-armed to fire in a different number of clock ticks by calling <a class="el" href="qfn_8h.html#0acd0429fdee5beb25d06607ca190846" title="Arm the QP-nano one-shot time event. Since the tick counter is a multi-byte variable...">QActive_arm()</a> again.<p>
The following example shows how to arm a one-shot time event from a state machine of an active object: <div class="fragment"><pre class="fragment"><a class="code" href="qepn_8h.html#76c35d858e243d1bd3106738573902d0" title="Type returned from a state-handler function.">QState</a> Pelican_carsGreen(Pelican *me) {
    <span class="keywordflow">switch</span> (<a class="code" href="qepn_8h.html#a094e6aed843e73b91fc3879e79139d5" title="macro to access the signal of the current event of a state machine">Q_SIG</a>(me)) {
        <span class="keywordflow">case</span> <a class="code" href="qepn_8h.html#e35e58b2153d1c63307c068315be9074c286909dd59290d1076b51d4cfdfaefe">Q_ENTRY_SIG</a>: {
            <a class="code" href="qfn_8h.html#0acd0429fdee5beb25d06607ca190846" title="Arm the QP-nano one-shot time event. Since the tick counter is a multi-byte variable...">QActive_arm</a>((<a class="code" href="struct_q_active.html" title="Active Object struct.">QActive</a> *)me, CARS_GREEN_MIN_TOUT);  <span class="comment">/* arm timer */</span>
            BSP_signalCars(CARS_GREEN);
            <span class="keywordflow">return</span> <a class="code" href="qepn_8h.html#54b2da5e70ef983cfa7ca74deac237a3" title="Value returned by a state-handler function when it handles the event.">Q_HANDLED</a>();
        }
        <span class="keywordflow">case</span> <a class="code" href="qepn_8h.html#e35e58b2153d1c63307c068315be907428691a94425fb031be4044e817e21a60">Q_INIT_SIG</a>: {
            <span class="keywordflow">return</span> <a class="code" href="qepn_8h.html#8f06cd90ba5060780fc61a4810e3eb50" title="Designates a target for an initial or regular transition. Q_TRAN() can be used both...">Q_TRAN</a>(&amp;Pelican_carsGreenNoPed);
        }
    }
    <span class="keywordflow">return</span> <a class="code" href="qepn_8h.html#d8abd2f7098c41ec464343d9d8f1eadc" title="Designates the superstate of a given state in an HSM.">Q_SUPER</a>(&amp;Pelican_carsEnabled);
}
</pre></div> 
<p>Definition at line <a class="el" href="qfn_8c-source.html#l00151">151</a> of file <a class="el" href="qfn_8c-source.html">qfn.c</a>.</p>

<p>References <a class="el" href="qpn__port_8h-source.html#l00188">QF_INT_LOCK</a>, and <a class="el" href="qfn_8h-source.html#l00168">QActive::tickCtr</a>.</p>

</div>
</div><p>
<a class="anchor" name="27256e6403711f1f55e2b6a586b00bab"></a><!-- doxytag: member="qfn.h::QActive_disarm" ref="27256e6403711f1f55e2b6a586b00bab" args="(QActive *me)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QActive_disarm           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_q_active.html">QActive</a> *&nbsp;</td>
          <td class="paramname"> <em>me</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Disarm a time event. Since the tick counter is a multi-byte variable in this case, the operation must be performed inside a critical section. 
<p>
The time event of the active object <em>me</em> gets disarmed (stopped).<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>You should not assume that the Q_TIMEOUT_SIG event will not arrive after you disarm the time event. The timeout evetn could be already in the event queue. </dd></dl>

<p>Definition at line <a class="el" href="qfn_8c-source.html#l00157">157</a> of file <a class="el" href="qfn_8c-source.html">qfn.c</a>.</p>

</div>
</div><p>
<a class="anchor" name="079baf20c44aae3d8b6bc1200c0b07a1"></a><!-- doxytag: member="qfn.h::QActive_post" ref="079baf20c44aae3d8b6bc1200c0b07a1" args="(QActive *me, QSignal sig, QParam par)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QActive_post           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_q_active.html">QActive</a> *&nbsp;</td>
          <td class="paramname"> <em>me</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="qepn_8h.html#5dae830cf35fbe668a3fa2b47452a36b">QSignal</a>&nbsp;</td>
          <td class="paramname"> <em>sig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="qepn_8h.html#691c7fae67ced229a9dd9fa1ef048379">QParam</a>&nbsp;</td>
          <td class="paramname"> <em>par</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Posts an event <em>e</em> directly to the event queue of the acitve object <em>prio</em> using the First-In-First-Out (FIFO) policy. This function briefly locks and unlocks interrupts to protect the queue integrity. 
<p>
Direct event posting is the only asynchronous communication method available in QF-nano. The following example illustrates how the Ped active object posts directly the PED_WAITING event to the PELICAN crossing active object. <div class="fragment"><pre class="fragment"><a class="code" href="qepn_8h.html#76c35d858e243d1bd3106738573902d0" title="Type returned from a state-handler function.">QState</a> Ped_wait(Ped *me) {
    <span class="keywordflow">switch</span> (<a class="code" href="qepn_8h.html#a094e6aed843e73b91fc3879e79139d5" title="macro to access the signal of the current event of a state machine">Q_SIG</a>(me)) {
        <span class="keywordflow">case</span> <a class="code" href="qepn_8h.html#e35e58b2153d1c63307c068315be9074c286909dd59290d1076b51d4cfdfaefe">Q_ENTRY_SIG</a>: {
            BSP_showState(me-&gt;super.prio, <span class="stringliteral">"wait"</span>);
            me-&gt;retryCtr = N_ATTEMPTS;
            <a class="code" href="qfn_8h.html#0acd0429fdee5beb25d06607ca190846" title="Arm the QP-nano one-shot time event. Since the tick counter is a multi-byte variable...">QActive_arm</a>((<a class="code" href="struct_q_active.html" title="Active Object struct.">QActive</a> *)me, WAIT_TOUT);
            <span class="keywordflow">return</span> <a class="code" href="qepn_8h.html#54b2da5e70ef983cfa7ca74deac237a3" title="Value returned by a state-handler function when it handles the event.">Q_HANDLED</a>();
        }
        <span class="keywordflow">case</span> <a class="code" href="qepn_8h.html#e35e58b2153d1c63307c068315be9074a589380759f20ac798908df5203c9947">Q_TIMEOUT_SIG</a>: {
            <span class="keywordflow">if</span> ((--me-&gt;retryCtr) != 0) {
                <a class="code" href="qfn_8h.html#0acd0429fdee5beb25d06607ca190846" title="Arm the QP-nano one-shot time event. Since the tick counter is a multi-byte variable...">QActive_arm</a>((<a class="code" href="struct_q_active.html" title="Active Object struct.">QActive</a> *)me, WAIT_TOUT);
                <a class="code" href="qfn_8h.html#079baf20c44aae3d8b6bc1200c0b07a1" title="Posts an event e directly to the event queue of the acitve object prio using the...">QActive_post</a>((<a class="code" href="struct_q_active.html" title="Active Object struct.">QActive</a> *)&amp;AO_Pelican, PEDS_WAITING_SIG, 0);
            }
            <span class="keywordflow">else</span> {
                <span class="keywordflow">return</span> <a class="code" href="qepn_8h.html#8f06cd90ba5060780fc61a4810e3eb50" title="Designates a target for an initial or regular transition. Q_TRAN() can be used both...">Q_TRAN</a>(&amp;Ped_off);
            }
            <span class="keywordflow">return</span> <a class="code" href="qepn_8h.html#54b2da5e70ef983cfa7ca74deac237a3" title="Value returned by a state-handler function when it handles the event.">Q_HANDLED</a>();
        }
    }
    <span class="keywordflow">return</span> <a class="code" href="qepn_8h.html#d8abd2f7098c41ec464343d9d8f1eadc" title="Designates the superstate of a given state in an HSM.">Q_SUPER</a>(&amp;<a class="code" href="qepn_8h.html#610f1deb5bf3b5d4ad7f605e0fbc2e30" title="The top-state.">QHsm_top</a>);
}
</pre></div><p>
The producer of the event (Ped in this case) must only "know" a pointer recipient (&amp;AO_Pelican), but the specific definition of the Pelican structure is not required.<p>
Direct event posting should not be confused with direct event dispatching. In contrast to asynchronous event posting through event queues, direct event dispatching is synchronous. Direct event dispatching occurs when you call <a class="el" href="qepn_8h.html#5ae42e7a6a93dc8a5354abdc99d67902" title="Dispatches an event to a HSM.">QHsm_dispatch()</a>, or <a class="el" href="qepn_8h.html#cce01c9a92f70758f07864245a3cb171" title="Dispatches an event to a FSM.">QFsm_dispatch()</a> function.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>This function is intended only to be used at the task level and shouln never be used inside ISRs. </dd></dl>

<p>Definition at line <a class="el" href="qfn_8c-source.html#l00048">48</a> of file <a class="el" href="qfn_8c-source.html">qfn.c</a>.</p>

<p>References <a class="el" href="qfn_8h-source.html#l00394">QActiveCB::end</a>, <a class="el" href="qfn_8h-source.html#l00154">QActive::head</a>, <a class="el" href="qfn_8h-source.html#l00163">QActive::nUsed</a>, <a class="el" href="qfn_8h-source.html#l00150">QActive::prio</a>, <a class="el" href="qassert_8h-source.html#l00095">Q_ASSERT</a>, <a class="el" href="qepn_8h-source.html#l00201">Q_PAR</a>, <a class="el" href="qpn__port_8h-source.html#l00132">Q_PARAM_SIZE</a>, <a class="el" href="qpn__port_8h-source.html#l00102">Q_ROM_BYTE</a>, <a class="el" href="qpn__port_8h-source.html#l00119">Q_ROM_PTR</a>, <a class="el" href="qepn_8h-source.html#l00193">Q_SIG</a>, <a class="el" href="qfn_8c-source.html#l00048">QActive_post()</a>, <a class="el" href="qfn_8h.html#d7859aaf627fc134851ae64c9ff9ed6f">QF_active</a>, <a class="el" href="qpn__port_8h-source.html#l00188">QF_INT_LOCK</a>, <a class="el" href="qpn__port_8h-source.html#l00198">QF_INT_UNLOCK</a>, <a class="el" href="qfn_8c-source.html#l00039">QF_readySet_</a>, <a class="el" href="qkn_8c-source.html#l00090">QK_schedule_()</a>, and <a class="el" href="qfn_8h-source.html#l00393">QActiveCB::queue</a>.</p>

<p>Referenced by <a class="el" href="qfn_8c-source.html#l00048">QActive_post()</a>.</p>

</div>
</div><p>
<a class="anchor" name="d0a147ddbdfc4d9450f64515ae75f7a6"></a><!-- doxytag: member="qfn.h::QActive_postISR" ref="d0a147ddbdfc4d9450f64515ae75f7a6" args="(QActive *me, QSignal sig, QParam par)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QActive_postISR           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_q_active.html">QActive</a> *&nbsp;</td>
          <td class="paramname"> <em>me</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="qepn_8h.html#5dae830cf35fbe668a3fa2b47452a36b">QSignal</a>&nbsp;</td>
          <td class="paramname"> <em>sig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="qepn_8h.html#691c7fae67ced229a9dd9fa1ef048379">QParam</a>&nbsp;</td>
          <td class="paramname"> <em>par</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Posts an event <em>e</em> directly to the event queue of the acitve object <em>prio</em> using the First-In-First-Out (FIFO) policy. This function does NOT lock/unlock interrupts when nesting of interrupts is not allowed. Also, this function never calls the QK-nano scheduler, because synchronous task preemptions are never necessary inside ISRs. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>This function is intended only to be used inside ISRs and you should never use at the task level.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd>QF_post() </dd></dl>

<p>Definition at line <a class="el" href="qfn_8c-source.html#l00083">83</a> of file <a class="el" href="qfn_8c-source.html">qfn.c</a>.</p>

<p>References <a class="el" href="qfn_8h-source.html#l00394">QActiveCB::end</a>, <a class="el" href="qfn_8h-source.html#l00154">QActive::head</a>, <a class="el" href="qfn_8h-source.html#l00163">QActive::nUsed</a>, <a class="el" href="qfn_8h-source.html#l00150">QActive::prio</a>, <a class="el" href="qassert_8h-source.html#l00095">Q_ASSERT</a>, <a class="el" href="qepn_8h-source.html#l00201">Q_PAR</a>, <a class="el" href="qpn__port_8h-source.html#l00132">Q_PARAM_SIZE</a>, <a class="el" href="qpn__port_8h-source.html#l00102">Q_ROM_BYTE</a>, <a class="el" href="qpn__port_8h-source.html#l00119">Q_ROM_PTR</a>, <a class="el" href="qepn_8h-source.html#l00193">Q_SIG</a>, <a class="el" href="qfn_8h.html#d7859aaf627fc134851ae64c9ff9ed6f">QF_active</a>, <a class="el" href="qpn__port_8h-source.html#l00188">QF_INT_LOCK</a>, <a class="el" href="qpn__port_8h-source.html#l00198">QF_INT_UNLOCK</a>, <a class="el" href="qfn_8c-source.html#l00039">QF_readySet_</a>, and <a class="el" href="qfn_8h-source.html#l00393">QActiveCB::queue</a>.</p>

<p>Referenced by <a class="el" href="qfn_8c-source.html#l00132">QF_tick()</a>.</p>

</div>
</div><p>
<a class="anchor" name="fcac91c9d71d70255fdd88db3fb16e24"></a><!-- doxytag: member="qfn.h::QF_onIdle" ref="fcac91c9d71d70255fdd88db3fb16e24" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QF_onIdle           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
QF idle callback (customized in BSPs for QF). 
<p>
<a class="el" href="qfn_8h.html#fcac91c9d71d70255fdd88db3fb16e24" title="QF idle callback (customized in BSPs for QF).">QF_onIdle()</a> is called by the non-preemptive scheduler built into QF-nano when the QF-nano detects that no events are available for active objects (the idle condition). This callback gives the application an opportunity to enter a power-saving CPU mode, or perform some other idle processing.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd><a class="el" href="qfn_8h.html#fcac91c9d71d70255fdd88db3fb16e24" title="QF idle callback (customized in BSPs for QF).">QF_onIdle()</a> is invoked with interrupts LOCKED because the idle condition can be asynchronously changed at any time by an interrupt. <a class="el" href="qfn_8h.html#fcac91c9d71d70255fdd88db3fb16e24" title="QF idle callback (customized in BSPs for QF).">QF_onIdle()</a> MUST unlock the interrupts internally, but not before putting the CPU into the low-power mode. (Ideally, unlocking interrupts and low-power mode should happen atomically). At the very least, the function MUST unlock interrupts, otherwise interrups will be locked permanently.<p>
<a class="el" href="qfn_8h.html#fcac91c9d71d70255fdd88db3fb16e24" title="QF idle callback (customized in BSPs for QF).">QF_onIdle()</a> is not used in the PREEMPTIVE configuration. When QK_PREEMPTIVE macro is defined, the preemptive kernel QK-nano is used instead of the non-preemptive QF-nano scheduler. QK-nano uses a different idle callback </dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="qkn_8h.html#667daad24b172e782fe4e2b5b06fbf61" title="QK idle callback (customized in BSPs for QK).">QK_onIdle()</a>. </dd></dl>

</div>
</div><p>
<a class="anchor" name="189a6d2ece787717c81fbf51fd180732"></a><!-- doxytag: member="qfn.h::QF_onStartup" ref="189a6d2ece787717c81fbf51fd180732" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QF_onStartup           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Startup QF-nano callback. 
<p>
The timeline for calling <a class="el" href="qfn_8h.html#189a6d2ece787717c81fbf51fd180732" title="Startup QF-nano callback.">QF_onStartup()</a> depends on the particular QF port. In most cases, <a class="el" href="qfn_8h.html#189a6d2ece787717c81fbf51fd180732" title="Startup QF-nano callback.">QF_onStartup()</a> is called from <a class="el" href="qfn_8h.html#7a41998117b4edb760b754f5ee3f61d5" title="Transfers control to QF to run the application.">QF_run()</a>, right before starting any multitasking kernel or the background loop.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd>QF initialization example for <a class="el" href="struct_q_active_c_b.html" title="QActive Control Block.">QActiveCB</a>. </dd></dl>

<p>Referenced by <a class="el" href="qkn_8c-source.html#l00058">QF_run()</a>.</p>

</div>
</div><p>
<a class="anchor" name="7a41998117b4edb760b754f5ee3f61d5"></a><!-- doxytag: member="qfn.h::QF_run" ref="7a41998117b4edb760b754f5ee3f61d5" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QF_run           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Transfers control to QF to run the application. 
<p>
<a class="el" href="qfn_8h.html#7a41998117b4edb760b754f5ee3f61d5" title="Transfers control to QF to run the application.">QF_run()</a> implemetns the simple non-preemptive scheduler. <a class="el" href="qfn_8h.html#7a41998117b4edb760b754f5ee3f61d5" title="Transfers control to QF to run the application.">QF_run()</a> must be called from your startup code after you initialize the QF and define at least one active object control block in QF_active[].<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>When the Quantum Kernel (QK) is used as the underlying real-time kernel for the QF, all platfrom dependencies are handled in the QK, so no porting of QF is necessary. In other words, you only need to recompile the QF platform-independent code with the compiler for your platform, but you don't need to provide any platform-specific implementation (so, no qf_port.c file is necessary). Moreover, QK implements the function <a class="el" href="qfn_8h.html#7a41998117b4edb760b754f5ee3f61d5" title="Transfers control to QF to run the application.">QF_run()</a> in a platform-independent way, in the modile qk.c. </dd></dl>

<p>Definition at line <a class="el" href="qkn_8c-source.html#l00058">58</a> of file <a class="el" href="qkn_8c-source.html">qkn.c</a>.</p>

<p>References <a class="el" href="qfn_8h-source.html#l00150">QActive::prio</a>, <a class="el" href="qassert_8h-source.html#l00095">Q_ASSERT</a>, <a class="el" href="qpn__port_8h-source.html#l00119">Q_ROM_PTR</a>, <a class="el" href="qfn_8h.html#d7859aaf627fc134851ae64c9ff9ed6f">QF_active</a>, <a class="el" href="qpn__port_8h-source.html#l00188">QF_INT_LOCK</a>, <a class="el" href="qpn__port_8h-source.html#l00198">QF_INT_UNLOCK</a>, <a class="el" href="qpn__port_8h-source.html#l00177">QF_MAX_ACTIVE</a>, <a class="el" href="qfn_8h.html#189a6d2ece787717c81fbf51fd180732">QF_onStartup()</a>, <a class="el" href="qepn_8c-source.html#l00055">QFsm_init()</a>, <a class="el" href="qepn_8c-source.html#l00086">QHsm_init()</a>, <a class="el" href="qkn_8h.html#667daad24b172e782fe4e2b5b06fbf61">QK_onIdle()</a>, and <a class="el" href="qkn_8h-source.html#l00084">QK_SCHEDULE_</a>.</p>

</div>
</div><p>
<a class="anchor" name="df9cb86740bf55c5ad55c1d44fd35921"></a><!-- doxytag: member="qfn.h::QF_stop" ref="df9cb86740bf55c5ad55c1d44fd35921" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QF_stop           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
QF-nano termination. 
<p>
This function terminates QF and performs any necessary cleanup. In QF-nano this function is defined in the BSP. Many QF ports might not require implementing <a class="el" href="qfn_8h.html#df9cb86740bf55c5ad55c1d44fd35921" title="QF-nano termination.">QF_stop()</a> at all, because many embedded applications don't have anything to exit to. 
</div>
</div><p>
<a class="anchor" name="fd1f18b068ca10c17eaa3431e77dd290"></a><!-- doxytag: member="qfn.h::QF_tick" ref="fd1f18b068ca10c17eaa3431e77dd290" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QF_tick           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Processes all armed time events at every clock tick. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>This function can be only calle from the ISR-level. You must also guarantee that <a class="el" href="qfn_8h.html#fd1f18b068ca10c17eaa3431e77dd290" title="Processes all armed time events at every clock tick.">QF_tick()</a> runs to completion before it is called again.</dd></dl>
The following example illustrates the call to <a class="el" href="qfn_8h.html#fd1f18b068ca10c17eaa3431e77dd290" title="Processes all armed time events at every clock tick.">QF_tick()</a>: <div class="fragment"><pre class="fragment"><span class="comment">/* the system time tick ISR for C8051 from Silicon Labs ....................*/</span>
<span class="preprocessor">#pragma vector=0x2B</span>
<span class="preprocessor"></span>__interrupt <span class="keywordtype">void</span> timer2_ISR(<span class="keywordtype">void</span>) {
   TMR2CN &amp;= ~(1 &lt;&lt; 7);                      <span class="comment">/* Clear Timer2 interrupt flag */</span>
   <a class="code" href="qfn_8h.html#fd1f18b068ca10c17eaa3431e77dd290" title="Processes all armed time events at every clock tick.">QF_tick</a>();                    <span class="comment">/* handle all armed time events in QF-nano */</span>
}

<span class="comment">/* the system time tick ISR for MSP430 from TI (non-preemptive case) .......*/</span>
<span class="preprocessor">#pragma vector = TIMERA0_VECTOR</span>
<span class="preprocessor"></span>__interrupt <span class="keywordtype">void</span> timerA_ISR(<span class="keywordtype">void</span>) {
    __low_power_mode_off_on_exit();
   <a class="code" href="qfn_8h.html#fd1f18b068ca10c17eaa3431e77dd290" title="Processes all armed time events at every clock tick.">QF_tick</a>();                    <span class="comment">/* handle all armed time events in QF-nano */</span>
}

<span class="comment">/* the system time tick ISR for MSP430 from TI (preemptive case QK-nano) ...*/</span>
<span class="preprocessor">#pragma vector = TIMERA0_VECTOR</span>
<span class="preprocessor"></span>__interrupt <span class="keywordtype">void</span> timerA_ISR(<span class="keywordtype">void</span>) {
    QK_ISR_ENTRY();                <span class="comment">/* inform QK-nano about entering the ISR */</span>
    <a class="code" href="qfn_8h.html#fd1f18b068ca10c17eaa3431e77dd290" title="Processes all armed time events at every clock tick.">QF_tick</a>();                   <span class="comment">/* handle all armed time events in QF-nano */</span>
    QK_ISR_EXIT();                  <span class="comment">/* inform QK-nano about exiting the ISR */</span>
}
</pre></div> 
<p>Definition at line <a class="el" href="qfn_8c-source.html#l00132">132</a> of file <a class="el" href="qfn_8c-source.html">qfn.c</a>.</p>

<p>References <a class="el" href="qpn__port_8h-source.html#l00119">Q_ROM_PTR</a>, <a class="el" href="qepn_8h-source.html#l00156">Q_TIMEOUT_SIG</a>, <a class="el" href="qfn_8c-source.html#l00083">QActive_postISR()</a>, <a class="el" href="qfn_8h.html#d7859aaf627fc134851ae64c9ff9ed6f">QF_active</a>, <a class="el" href="qpn__port_8h-source.html#l00177">QF_MAX_ACTIVE</a>, and <a class="el" href="qfn_8h-source.html#l00168">QActive::tickCtr</a>.</p>

</div>
</div><p>
<hr><h2>Variable Documentation</h2>
<a class="anchor" name="d7859aaf627fc134851ae64c9ff9ed6f"></a><!-- doxytag: member="qfn.h::QF_active" ref="d7859aaf627fc134851ae64c9ff9ed6f" args="[]" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_q_active_c_b.html">QActiveCB</a> const Q_ROM Q_ROM_VAR <a class="el" href="qfn_8h.html#d7859aaf627fc134851ae64c9ff9ed6f">QF_active</a>[]          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
active object control blocks 
<p>Referenced by <a class="el" href="qfn_8c-source.html#l00048">QActive_post()</a>, <a class="el" href="qfn_8c-source.html#l00083">QActive_postISR()</a>, <a class="el" href="qkn_8c-source.html#l00058">QF_run()</a>, <a class="el" href="qfn_8c-source.html#l00132">QF_tick()</a>, and <a class="el" href="qkn_8c-source.html#l00090">QK_schedule_()</a>.</p>

</div>
</div><p>
<a class="anchor" name="2be032c7d9fdaa52f5e89d0f8856b768"></a><!-- doxytag: member="qfn.h::QF_readySet_" ref="2be032c7d9fdaa52f5e89d0f8856b768" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t volatile <a class="el" href="qfn_8c.html#2be032c7d9fdaa52f5e89d0f8856b768">QF_readySet_</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Ready set of QF-nano. 
<p>
The QF-nano ready set keeps track of active objects that are ready to run. The ready set represents each active object as a bit, with the bits assigned according to priorities of the active objects. The bit is set if the corresponding active object is ready to run (i.e., has one or more events in its event queue) and zero if the event queue is empty. The QF-nano ready set is one byte-wide, which corresponds to 8 active objects maximum. 
<p>Definition at line <a class="el" href="qfn_8c-source.html#l00039">39</a> of file <a class="el" href="qfn_8c-source.html">qfn.c</a>.</p>

<p>Referenced by <a class="el" href="qfn_8c-source.html#l00048">QActive_post()</a>, <a class="el" href="qfn_8c-source.html#l00083">QActive_postISR()</a>, and <a class="el" href="qkn_8c-source.html#l00090">QK_schedule_()</a>.</p>

</div>
</div><p>
<hr size="1"><address style="text-align: right;"><small>Generated on Thu Apr 9 13:26:44 2009 for QP-nano by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.4 </small></address>
</body>
</html>
