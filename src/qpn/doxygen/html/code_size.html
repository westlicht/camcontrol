<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>QP-nano: 9. QP-nano Memory Usage</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.4 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="classes.html"><span>Data&nbsp;Structures</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul>
</div>
<div class="nav">
<a class="el" href="index.html">QP-nano Reference Manual</a>&nbsp;&raquo&nbsp;<a class="el" href="tutorial_page.html">QP-nano Tutorial</a></div>
<h1><a class="anchor" name="code_size">9. QP-nano Memory Usage </a></h1><em>This QP-nano Tutorial is adapted from Chapter 1 of <a class="el" href="index.html#PSiCC2">Practical UML Statecharts in C/C++, Second Edition</a><br>
 by Miro Samek, the founder and president of Quantum Leaps, LLC.</em><p>
<div align="center">
<img src="qp_tutorial.jpg" alt="qp_tutorial.jpg">
</div>
<p>
Prev: <a class="el" href="execution.html">8. Using the Built-in Real-Time Kernels</a> <br>
 Next: <a class="el" href="comparison.html">10. Comparison to the Traditional Approach</a><p>
To give you an idea of the QP-nano memory usage, <a class="el" href="code_size.html#T10s1">Table 10-1</a> and <a class="el" href="code_size.html#T10s2">10-2</a> show the memory footprint of the QP-nano components for various settings of the configuration macros. The data for <a class="el" href="code_size.html#T10s1">Table 10-1</a> has been obtained from the IAR compiler for MSP430 v4.10A (the KickStart edition), while data for <a class="el" href="code_size.html#T10s2">Table 10-2</a> has been obtained from the IAR compiler for ARM Cortex-M3 v5.11 (also the KickStart edition). In both cases I have selected optimization level High/Size. The first column of <a class="el" href="code_size.html#T10s1">Table 10-1</a> and <a class="el" href="code_size.html#T10s2">10-2</a> lists the configuration macros that are significant for the RAM or ROM usage in QP-nano. I have omitted the QF_ISR_NEST and QF_ISR_KEY_TYPE macros, as they have virtually no impact on the code or data sizes shown in the tables (even though, defining QF_ISR_KEY_TYPE increases somewhat the stack usage.) Both MSP430 and Cortex-M3 offer good code density and the IAR compiler generates fantastic machine code for these CPU architectures. (I've seen much worse results for older CPU architectures, such as 8051 or the PIC). Therefore, you should treat the data in <a class="el" href="code_size.html#T10s1">Table 10-1</a> and <a class="el" href="code_size.html#T10s2">10-2</a> as minimum memory footprint of QP-nano rather than average results. The intent of <a class="el" href="code_size.html#T10s1">Table 10-1</a> is primarily to give you a general idea for the <b>relative</b> cost of various options, rather than to provide you absolutely accurate measurements.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The <a class="el" href="code_size.html#T10s1">Table 10-1</a> and <a class="el" href="code_size.html#T10s2">10-2</a> show only the memory used directly by the QP-nano components, but do not include the memory required by the application. In particular, you don't see the stack usage, or the RAM required by active objects and their event queues.</dd></dl>
<a class="anchor" name="T10s1"></a> <div align="center">
<img src="Tab12.01.jpg" alt="Tab12.01.jpg">
<p><strong>Table 10-1 QP-nano memory usage in bytes for various settings of the configuration parameters (MSP430/IAR compiler/optimization-High/Size)</strong></p></div>
 <a class="anchor" name="T10s2"></a> <div align="center">
<img src="Tab12.02.jpg" alt="Tab12.02.jpg">
<p><strong>Table 10-2 QP-nano memory usage in bytes for various settings of the configuration parameters (ARM Cortex-M3/IAR compiler/optimization-High/Size)</strong></p></div>
 The various QP-nano configurations are listed in <a class="el" href="code_size.html#T10s1">Table 10-1</a> and <a class="el" href="code_size.html#T10s2">10-2</a> separately for the non-preemptive "vanilla" kernel (configurations 1-6) and the preemptive QK-nano kernel (configurations 7-12). Within each group, the simpler configurations come before the more expensive ones. For example, the absolutely minimal configuration number 1 eliminates the HSM code (so only basic FSM support is provided), uses no event parameters, no time events, and up to 4 active objects. This minimal configuration is clearly very limited. However, the configuration number 4 is already quite reasonable. It still offers only non-hierarchical FSMs, but includes event parameter, time events, and up to 8 active objects, at the cost of less than 700 bytes of code space. By far, the most expensive feature (in terms of ROM) is the HSM support, which costs about 650 bytes (e.g., compare configurations number 4 and 5 or 10 and 11). On the other hand, the QK-nano preemptive kernel increases the ROM footprint only by 50-100 bytes compared to the "vanilla" kernel. Obviously, the true cost of QK-nano lies in the increased stack requirements, which <a class="el" href="code_size.html#T10s1">Table 10-1</a> and <a class="el" href="code_size.html#T10s2">10-2</a> don't show.<p>
Prev: <a class="el" href="execution.html">8. Using the Built-in Real-Time Kernels</a> <br>
 Next: <a class="el" href="comparison.html">10. Comparison to the Traditional Approach</a><p>
<div align="center">
<img src="logo_ql_TM.jpg" alt="logo_ql_TM.jpg">
</div>
 Copyright &copy; 2002-2008 Quantum Leaps, LLC. All Rights Reserved.<br>
 <a href="http://www.quantum-leaps.com">http://www.quantum-leaps.com</a> <hr size="1"><address style="text-align: right;"><small>Generated on Thu Apr 9 13:26:46 2009 for QP-nano by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.4 </small></address>
</body>
</html>
