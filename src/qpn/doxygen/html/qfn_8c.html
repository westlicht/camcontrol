<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>QP-nano: qfn.c File Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.4 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="classes.html"><span>Data&nbsp;Structures</span></a></li>
    <li class="current"><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul>
</div>
<h1>qfn.c File Reference</h1><code>#include &quot;<a class="el" href="qpn__port_8h-source.html">qpn_port.h</a>&quot;</code><br>

<p>
<a href="qfn_8c-source.html">Go to the source code of this file.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="qfn_8c.html#079baf20c44aae3d8b6bc1200c0b07a1">QActive_post</a> (<a class="el" href="struct_q_active.html">QActive</a> *me, <a class="el" href="qepn_8h.html#5dae830cf35fbe668a3fa2b47452a36b">QSignal</a> sig, <a class="el" href="qepn_8h.html#691c7fae67ced229a9dd9fa1ef048379">QParam</a> par)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Posts an event <em>e</em> directly to the event queue of the acitve object <em>prio</em> using the First-In-First-Out (FIFO) policy. This function briefly locks and unlocks interrupts to protect the queue integrity.  <a href="#079baf20c44aae3d8b6bc1200c0b07a1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="qfn_8c.html#d0a147ddbdfc4d9450f64515ae75f7a6">QActive_postISR</a> (<a class="el" href="struct_q_active.html">QActive</a> *me, <a class="el" href="qepn_8h.html#5dae830cf35fbe668a3fa2b47452a36b">QSignal</a> sig, <a class="el" href="qepn_8h.html#691c7fae67ced229a9dd9fa1ef048379">QParam</a> par)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Posts an event <em>e</em> directly to the event queue of the acitve object <em>prio</em> using the First-In-First-Out (FIFO) policy. This function does NOT lock/unlock interrupts when nesting of interrupts is not allowed. Also, this function never calls the QK-nano scheduler, because synchronous task preemptions are never necessary inside ISRs.  <a href="#d0a147ddbdfc4d9450f64515ae75f7a6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="qfn_8c.html#fd1f18b068ca10c17eaa3431e77dd290">QF_tick</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Processes all armed time events at every clock tick.  <a href="#fd1f18b068ca10c17eaa3431e77dd290"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="qfn_8c.html#0acd0429fdee5beb25d06607ca190846">QActive_arm</a> (<a class="el" href="struct_q_active.html">QActive</a> *me, <a class="el" href="qfn_8h.html#4c9ee418dab7af7004cfd9ebbb5bc8f5">QTimeEvtCtr</a> tout)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Arm the QP-nano one-shot time event. Since the tick counter is a multi-byte variable in this case, the operation must be performed inside a critical section.  <a href="#0acd0429fdee5beb25d06607ca190846"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="qfn_8c.html#27256e6403711f1f55e2b6a586b00bab">QActive_disarm</a> (<a class="el" href="struct_q_active.html">QActive</a> *me)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Disarm a time event. Since the tick counter is a multi-byte variable in this case, the operation must be performed inside a critical section.  <a href="#27256e6403711f1f55e2b6a586b00bab"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Variables</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">uint8_t volatile&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="qfn_8c.html#2be032c7d9fdaa52f5e89d0f8856b768">QF_readySet_</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Ready set of QF-nano.  <a href="#2be032c7d9fdaa52f5e89d0f8856b768"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
QF-nano implementation. 
<p>Definition in file <a class="el" href="qfn_8c-source.html">qfn.c</a>.</p>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="0acd0429fdee5beb25d06607ca190846"></a><!-- doxytag: member="qfn.c::QActive_arm" ref="0acd0429fdee5beb25d06607ca190846" args="(QActive *me, QTimeEvtCtr tout)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QActive_arm           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_q_active.html">QActive</a> *&nbsp;</td>
          <td class="paramname"> <em>me</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="qfn_8h.html#4c9ee418dab7af7004cfd9ebbb5bc8f5">QTimeEvtCtr</a>&nbsp;</td>
          <td class="paramname"> <em>tout</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Arm the QP-nano one-shot time event. Since the tick counter is a multi-byte variable in this case, the operation must be performed inside a critical section. 
<p>
Arms the time event of the active object <em>me</em> to expire in <em>tout</em> clock ticks (one-shot time event). Upon the expiration, the time event posts the reserved signal Q_TIMEOUT_SIG directly into the event queue of the active object <em>me</em>.<p>
After posting, the time event gets automatically disarmed.<p>
The time event can be disarmed (stoped) at any time by calling the <a class="el" href="qfn_8h.html#27256e6403711f1f55e2b6a586b00bab" title="Disarm a time event. Since the tick counter is a multi-byte variable in this case...">QActive_disarm()</a> function. Also, a one-shot time event can be re-armed to fire in a different number of clock ticks by calling <a class="el" href="qfn_8h.html#0acd0429fdee5beb25d06607ca190846" title="Arm the QP-nano one-shot time event. Since the tick counter is a multi-byte variable...">QActive_arm()</a> again.<p>
The following example shows how to arm a one-shot time event from a state machine of an active object: <div class="fragment"><pre class="fragment"><a class="code" href="qepn_8h.html#76c35d858e243d1bd3106738573902d0" title="Type returned from a state-handler function.">QState</a> Pelican_carsGreen(Pelican *me) {
    <span class="keywordflow">switch</span> (<a class="code" href="qepn_8h.html#a094e6aed843e73b91fc3879e79139d5" title="macro to access the signal of the current event of a state machine">Q_SIG</a>(me)) {
        <span class="keywordflow">case</span> <a class="code" href="qepn_8h.html#e35e58b2153d1c63307c068315be9074c286909dd59290d1076b51d4cfdfaefe">Q_ENTRY_SIG</a>: {
            <a class="code" href="qfn_8h.html#0acd0429fdee5beb25d06607ca190846" title="Arm the QP-nano one-shot time event. Since the tick counter is a multi-byte variable...">QActive_arm</a>((<a class="code" href="struct_q_active.html" title="Active Object struct.">QActive</a> *)me, CARS_GREEN_MIN_TOUT);  <span class="comment">/* arm timer */</span>
            BSP_signalCars(CARS_GREEN);
            <span class="keywordflow">return</span> <a class="code" href="qepn_8h.html#54b2da5e70ef983cfa7ca74deac237a3" title="Value returned by a state-handler function when it handles the event.">Q_HANDLED</a>();
        }
        <span class="keywordflow">case</span> <a class="code" href="qepn_8h.html#e35e58b2153d1c63307c068315be907428691a94425fb031be4044e817e21a60">Q_INIT_SIG</a>: {
            <span class="keywordflow">return</span> <a class="code" href="qepn_8h.html#8f06cd90ba5060780fc61a4810e3eb50" title="Designates a target for an initial or regular transition. Q_TRAN() can be used both...">Q_TRAN</a>(&amp;Pelican_carsGreenNoPed);
        }
    }
    <span class="keywordflow">return</span> <a class="code" href="qepn_8h.html#d8abd2f7098c41ec464343d9d8f1eadc" title="Designates the superstate of a given state in an HSM.">Q_SUPER</a>(&amp;Pelican_carsEnabled);
}
</pre></div> 
<p>Definition at line <a class="el" href="qfn_8c-source.html#l00151">151</a> of file <a class="el" href="qfn_8c-source.html">qfn.c</a>.</p>

<p>References <a class="el" href="qpn__port_8h-source.html#l00188">QF_INT_LOCK</a>, and <a class="el" href="qfn_8h-source.html#l00168">QActive::tickCtr</a>.</p>

</div>
</div><p>
<a class="anchor" name="27256e6403711f1f55e2b6a586b00bab"></a><!-- doxytag: member="qfn.c::QActive_disarm" ref="27256e6403711f1f55e2b6a586b00bab" args="(QActive *me)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QActive_disarm           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_q_active.html">QActive</a> *&nbsp;</td>
          <td class="paramname"> <em>me</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Disarm a time event. Since the tick counter is a multi-byte variable in this case, the operation must be performed inside a critical section. 
<p>
The time event of the active object <em>me</em> gets disarmed (stopped).<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>You should not assume that the Q_TIMEOUT_SIG event will not arrive after you disarm the time event. The timeout evetn could be already in the event queue. </dd></dl>

<p>Definition at line <a class="el" href="qfn_8c-source.html#l00157">157</a> of file <a class="el" href="qfn_8c-source.html">qfn.c</a>.</p>

</div>
</div><p>
<a class="anchor" name="079baf20c44aae3d8b6bc1200c0b07a1"></a><!-- doxytag: member="qfn.c::QActive_post" ref="079baf20c44aae3d8b6bc1200c0b07a1" args="(QActive *me, QSignal sig, QParam par)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QActive_post           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_q_active.html">QActive</a> *&nbsp;</td>
          <td class="paramname"> <em>me</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="qepn_8h.html#5dae830cf35fbe668a3fa2b47452a36b">QSignal</a>&nbsp;</td>
          <td class="paramname"> <em>sig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="qepn_8h.html#691c7fae67ced229a9dd9fa1ef048379">QParam</a>&nbsp;</td>
          <td class="paramname"> <em>par</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Posts an event <em>e</em> directly to the event queue of the acitve object <em>prio</em> using the First-In-First-Out (FIFO) policy. This function briefly locks and unlocks interrupts to protect the queue integrity. 
<p>
Direct event posting is the only asynchronous communication method available in QF-nano. The following example illustrates how the Ped active object posts directly the PED_WAITING event to the PELICAN crossing active object. <div class="fragment"><pre class="fragment"><a class="code" href="qepn_8h.html#76c35d858e243d1bd3106738573902d0" title="Type returned from a state-handler function.">QState</a> Ped_wait(Ped *me) {
    <span class="keywordflow">switch</span> (<a class="code" href="qepn_8h.html#a094e6aed843e73b91fc3879e79139d5" title="macro to access the signal of the current event of a state machine">Q_SIG</a>(me)) {
        <span class="keywordflow">case</span> <a class="code" href="qepn_8h.html#e35e58b2153d1c63307c068315be9074c286909dd59290d1076b51d4cfdfaefe">Q_ENTRY_SIG</a>: {
            BSP_showState(me-&gt;super.prio, <span class="stringliteral">"wait"</span>);
            me-&gt;retryCtr = N_ATTEMPTS;
            <a class="code" href="qfn_8h.html#0acd0429fdee5beb25d06607ca190846" title="Arm the QP-nano one-shot time event. Since the tick counter is a multi-byte variable...">QActive_arm</a>((<a class="code" href="struct_q_active.html" title="Active Object struct.">QActive</a> *)me, WAIT_TOUT);
            <span class="keywordflow">return</span> <a class="code" href="qepn_8h.html#54b2da5e70ef983cfa7ca74deac237a3" title="Value returned by a state-handler function when it handles the event.">Q_HANDLED</a>();
        }
        <span class="keywordflow">case</span> <a class="code" href="qepn_8h.html#e35e58b2153d1c63307c068315be9074a589380759f20ac798908df5203c9947">Q_TIMEOUT_SIG</a>: {
            <span class="keywordflow">if</span> ((--me-&gt;retryCtr) != 0) {
                <a class="code" href="qfn_8h.html#0acd0429fdee5beb25d06607ca190846" title="Arm the QP-nano one-shot time event. Since the tick counter is a multi-byte variable...">QActive_arm</a>((<a class="code" href="struct_q_active.html" title="Active Object struct.">QActive</a> *)me, WAIT_TOUT);
                <a class="code" href="qfn_8h.html#079baf20c44aae3d8b6bc1200c0b07a1" title="Posts an event e directly to the event queue of the acitve object prio using the...">QActive_post</a>((<a class="code" href="struct_q_active.html" title="Active Object struct.">QActive</a> *)&amp;AO_Pelican, PEDS_WAITING_SIG, 0);
            }
            <span class="keywordflow">else</span> {
                <span class="keywordflow">return</span> <a class="code" href="qepn_8h.html#8f06cd90ba5060780fc61a4810e3eb50" title="Designates a target for an initial or regular transition. Q_TRAN() can be used both...">Q_TRAN</a>(&amp;Ped_off);
            }
            <span class="keywordflow">return</span> <a class="code" href="qepn_8h.html#54b2da5e70ef983cfa7ca74deac237a3" title="Value returned by a state-handler function when it handles the event.">Q_HANDLED</a>();
        }
    }
    <span class="keywordflow">return</span> <a class="code" href="qepn_8h.html#d8abd2f7098c41ec464343d9d8f1eadc" title="Designates the superstate of a given state in an HSM.">Q_SUPER</a>(&amp;<a class="code" href="qepn_8h.html#610f1deb5bf3b5d4ad7f605e0fbc2e30" title="The top-state.">QHsm_top</a>);
}
</pre></div><p>
The producer of the event (Ped in this case) must only "know" a pointer recipient (&amp;AO_Pelican), but the specific definition of the Pelican structure is not required.<p>
Direct event posting should not be confused with direct event dispatching. In contrast to asynchronous event posting through event queues, direct event dispatching is synchronous. Direct event dispatching occurs when you call <a class="el" href="qepn_8h.html#5ae42e7a6a93dc8a5354abdc99d67902" title="Dispatches an event to a HSM.">QHsm_dispatch()</a>, or <a class="el" href="qepn_8h.html#cce01c9a92f70758f07864245a3cb171" title="Dispatches an event to a FSM.">QFsm_dispatch()</a> function.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>This function is intended only to be used at the task level and shouln never be used inside ISRs. </dd></dl>

<p>Definition at line <a class="el" href="qfn_8c-source.html#l00048">48</a> of file <a class="el" href="qfn_8c-source.html">qfn.c</a>.</p>

<p>References <a class="el" href="qfn_8h-source.html#l00394">QActiveCB::end</a>, <a class="el" href="qfn_8h-source.html#l00154">QActive::head</a>, <a class="el" href="qfn_8h-source.html#l00163">QActive::nUsed</a>, <a class="el" href="qfn_8h-source.html#l00150">QActive::prio</a>, <a class="el" href="qassert_8h-source.html#l00095">Q_ASSERT</a>, <a class="el" href="qepn_8h-source.html#l00201">Q_PAR</a>, <a class="el" href="qpn__port_8h-source.html#l00132">Q_PARAM_SIZE</a>, <a class="el" href="qpn__port_8h-source.html#l00102">Q_ROM_BYTE</a>, <a class="el" href="qpn__port_8h-source.html#l00119">Q_ROM_PTR</a>, <a class="el" href="qepn_8h-source.html#l00193">Q_SIG</a>, <a class="el" href="qfn_8c-source.html#l00048">QActive_post()</a>, <a class="el" href="qfn_8h.html#d7859aaf627fc134851ae64c9ff9ed6f">QF_active</a>, <a class="el" href="qpn__port_8h-source.html#l00188">QF_INT_LOCK</a>, <a class="el" href="qpn__port_8h-source.html#l00198">QF_INT_UNLOCK</a>, <a class="el" href="qfn_8c-source.html#l00039">QF_readySet_</a>, <a class="el" href="qkn_8c-source.html#l00090">QK_schedule_()</a>, and <a class="el" href="qfn_8h-source.html#l00393">QActiveCB::queue</a>.</p>

<p>Referenced by <a class="el" href="qfn_8c-source.html#l00048">QActive_post()</a>.</p>

</div>
</div><p>
<a class="anchor" name="d0a147ddbdfc4d9450f64515ae75f7a6"></a><!-- doxytag: member="qfn.c::QActive_postISR" ref="d0a147ddbdfc4d9450f64515ae75f7a6" args="(QActive *me, QSignal sig, QParam par)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QActive_postISR           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_q_active.html">QActive</a> *&nbsp;</td>
          <td class="paramname"> <em>me</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="qepn_8h.html#5dae830cf35fbe668a3fa2b47452a36b">QSignal</a>&nbsp;</td>
          <td class="paramname"> <em>sig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="qepn_8h.html#691c7fae67ced229a9dd9fa1ef048379">QParam</a>&nbsp;</td>
          <td class="paramname"> <em>par</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Posts an event <em>e</em> directly to the event queue of the acitve object <em>prio</em> using the First-In-First-Out (FIFO) policy. This function does NOT lock/unlock interrupts when nesting of interrupts is not allowed. Also, this function never calls the QK-nano scheduler, because synchronous task preemptions are never necessary inside ISRs. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>This function is intended only to be used inside ISRs and you should never use at the task level.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd>QF_post() </dd></dl>

<p>Definition at line <a class="el" href="qfn_8c-source.html#l00083">83</a> of file <a class="el" href="qfn_8c-source.html">qfn.c</a>.</p>

<p>References <a class="el" href="qfn_8h-source.html#l00394">QActiveCB::end</a>, <a class="el" href="qfn_8h-source.html#l00154">QActive::head</a>, <a class="el" href="qfn_8h-source.html#l00163">QActive::nUsed</a>, <a class="el" href="qfn_8h-source.html#l00150">QActive::prio</a>, <a class="el" href="qassert_8h-source.html#l00095">Q_ASSERT</a>, <a class="el" href="qepn_8h-source.html#l00201">Q_PAR</a>, <a class="el" href="qpn__port_8h-source.html#l00132">Q_PARAM_SIZE</a>, <a class="el" href="qpn__port_8h-source.html#l00102">Q_ROM_BYTE</a>, <a class="el" href="qpn__port_8h-source.html#l00119">Q_ROM_PTR</a>, <a class="el" href="qepn_8h-source.html#l00193">Q_SIG</a>, <a class="el" href="qfn_8h.html#d7859aaf627fc134851ae64c9ff9ed6f">QF_active</a>, <a class="el" href="qpn__port_8h-source.html#l00188">QF_INT_LOCK</a>, <a class="el" href="qpn__port_8h-source.html#l00198">QF_INT_UNLOCK</a>, <a class="el" href="qfn_8c-source.html#l00039">QF_readySet_</a>, and <a class="el" href="qfn_8h-source.html#l00393">QActiveCB::queue</a>.</p>

<p>Referenced by <a class="el" href="qfn_8c-source.html#l00132">QF_tick()</a>.</p>

</div>
</div><p>
<a class="anchor" name="fd1f18b068ca10c17eaa3431e77dd290"></a><!-- doxytag: member="qfn.c::QF_tick" ref="fd1f18b068ca10c17eaa3431e77dd290" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QF_tick           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Processes all armed time events at every clock tick. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>This function can be only calle from the ISR-level. You must also guarantee that <a class="el" href="qfn_8h.html#fd1f18b068ca10c17eaa3431e77dd290" title="Processes all armed time events at every clock tick.">QF_tick()</a> runs to completion before it is called again.</dd></dl>
The following example illustrates the call to <a class="el" href="qfn_8h.html#fd1f18b068ca10c17eaa3431e77dd290" title="Processes all armed time events at every clock tick.">QF_tick()</a>: <div class="fragment"><pre class="fragment"><span class="comment">/* the system time tick ISR for C8051 from Silicon Labs ....................*/</span>
<span class="preprocessor">#pragma vector=0x2B</span>
<span class="preprocessor"></span>__interrupt <span class="keywordtype">void</span> timer2_ISR(<span class="keywordtype">void</span>) {
   TMR2CN &amp;= ~(1 &lt;&lt; 7);                      <span class="comment">/* Clear Timer2 interrupt flag */</span>
   <a class="code" href="qfn_8h.html#fd1f18b068ca10c17eaa3431e77dd290" title="Processes all armed time events at every clock tick.">QF_tick</a>();                    <span class="comment">/* handle all armed time events in QF-nano */</span>
}

<span class="comment">/* the system time tick ISR for MSP430 from TI (non-preemptive case) .......*/</span>
<span class="preprocessor">#pragma vector = TIMERA0_VECTOR</span>
<span class="preprocessor"></span>__interrupt <span class="keywordtype">void</span> timerA_ISR(<span class="keywordtype">void</span>) {
    __low_power_mode_off_on_exit();
   <a class="code" href="qfn_8h.html#fd1f18b068ca10c17eaa3431e77dd290" title="Processes all armed time events at every clock tick.">QF_tick</a>();                    <span class="comment">/* handle all armed time events in QF-nano */</span>
}

<span class="comment">/* the system time tick ISR for MSP430 from TI (preemptive case QK-nano) ...*/</span>
<span class="preprocessor">#pragma vector = TIMERA0_VECTOR</span>
<span class="preprocessor"></span>__interrupt <span class="keywordtype">void</span> timerA_ISR(<span class="keywordtype">void</span>) {
    QK_ISR_ENTRY();                <span class="comment">/* inform QK-nano about entering the ISR */</span>
    <a class="code" href="qfn_8h.html#fd1f18b068ca10c17eaa3431e77dd290" title="Processes all armed time events at every clock tick.">QF_tick</a>();                   <span class="comment">/* handle all armed time events in QF-nano */</span>
    QK_ISR_EXIT();                  <span class="comment">/* inform QK-nano about exiting the ISR */</span>
}
</pre></div> 
<p>Definition at line <a class="el" href="qfn_8c-source.html#l00132">132</a> of file <a class="el" href="qfn_8c-source.html">qfn.c</a>.</p>

<p>References <a class="el" href="qpn__port_8h-source.html#l00119">Q_ROM_PTR</a>, <a class="el" href="qepn_8h-source.html#l00156">Q_TIMEOUT_SIG</a>, <a class="el" href="qfn_8c-source.html#l00083">QActive_postISR()</a>, <a class="el" href="qfn_8h.html#d7859aaf627fc134851ae64c9ff9ed6f">QF_active</a>, <a class="el" href="qpn__port_8h-source.html#l00177">QF_MAX_ACTIVE</a>, and <a class="el" href="qfn_8h-source.html#l00168">QActive::tickCtr</a>.</p>

</div>
</div><p>
<hr><h2>Variable Documentation</h2>
<a class="anchor" name="2be032c7d9fdaa52f5e89d0f8856b768"></a><!-- doxytag: member="qfn.c::QF_readySet_" ref="2be032c7d9fdaa52f5e89d0f8856b768" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t volatile <a class="el" href="qfn_8c.html#2be032c7d9fdaa52f5e89d0f8856b768">QF_readySet_</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Ready set of QF-nano. 
<p>
The QF-nano ready set keeps track of active objects that are ready to run. The ready set represents each active object as a bit, with the bits assigned according to priorities of the active objects. The bit is set if the corresponding active object is ready to run (i.e., has one or more events in its event queue) and zero if the event queue is empty. The QF-nano ready set is one byte-wide, which corresponds to 8 active objects maximum. 
<p>Definition at line <a class="el" href="qfn_8c-source.html#l00039">39</a> of file <a class="el" href="qfn_8c-source.html">qfn.c</a>.</p>

<p>Referenced by <a class="el" href="qfn_8c-source.html#l00048">QActive_post()</a>, <a class="el" href="qfn_8c-source.html#l00083">QActive_postISR()</a>, and <a class="el" href="qkn_8c-source.html#l00090">QK_schedule_()</a>.</p>

</div>
</div><p>
<hr size="1"><address style="text-align: right;"><small>Generated on Thu Apr 9 13:26:44 2009 for QP-nano by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.4 </small></address>
</body>
</html>
